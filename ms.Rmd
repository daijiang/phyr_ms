---
title: "`phyr`: An R package for model-based phylogenetic analyses"
author: "Daijiang Li, Russell Dinnage, Lucas Nell, Anthony Ives"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  bookdown::html_document2:
    number_sections: no
    theme: sandstone
    toc: yes
    css: style.css
  bookdown::word_document2: 
    toc: no
  bookdown::tufte_html2:
    number_sections: no
    toc: yes
fontsize: 12pt
link-citations: yes
always_allow_html: yes
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/methods-in-ecology-and-evolution.csl
bibliography: ref.bib
---

```{r knitr_options, include = FALSE}
if(!require("xfun")) install.packages("xfun")
if(!require("phyr")) devtools::install_github("daijiang/phyr")
xfun::pkg_attach2(c("phyr", "knitr", "kableExtra", "kableExtra", "tidyverse"))
# opts_knit$set(root.dir = normalizePath("../"))
opts_chunk$set(fig.align='center', cache = FALSE, warning = FALSE, 
               message = FALSE, echo = TRUE)
options(digits = 3, width = 88, knitr.kable.NA = '')

comm = phyr::comm_a
set.seed(1234)
comm = comm[sample(nrow(comm), 5), sample(ncol(comm), 5)]
comm$site = row.names(comm)
dat = tidyr::gather(comm, key = "sp", value = "freq", -site) %>% 
  left_join(phyr::envi, by = "site") %>% 
  left_join(phyr::traits, by = "sp")
dat$pa = as.numeric(dat$freq > 0)
dat$freq2 = 20 - dat$freq
pglmm_example = phyr::communityPGLMM(freq ~ 1 + shade + (1 | sp__) + (1 | site) + (1 | sp__@site), 
                     data = dat, tree = phyr::phylotree)
```

Running Title: Model-based phylogenetic analyses

*Summary*

1. Phylogenetic relationships among species are both a challenge and an opportunity for community ecology and comparative biology. Model-based phylogenetic analysis has advantages ... Currently, R functions to conduct these analyses were distributed across different packages and were mostly written in R, which can be very slow with large datasets.
2. To help remedy this situation, we created `phyr`, an R package that collects and updates functions to conduct model-based phylogenetic analyses. By collecting these functions into one package and rewrite core functions in c++, this package can facilitate the use of model-based phylogenetic analyses.
3. This paper presents the main functions of the package and provides an example using simulated data.
4. The `phyr` package provides a unified software environment with improved performance to conduct model-based phylogenetic analyses.

# Introduction

(2-3 paragraphs)

Phylogenetic relationships: importance and challenges

Model-based methods for phylogenetic analysis: advantages

The need of an R package to facilitate model-based phylogenetic analysis

Example of citations: [@r2017], [@ives2011generalized; @ives2018book]

# Package architecture

Main functions in `phyr` can be categorized into three groups (Table \@ref(tab:mainFunc)): A) phylogenetic diversity (alpha and beta), B) species' characteristics (e.g. correlations among traits, relationships between traits and environmental variables), and C) community assembly.

(ref:maunFuncCaption) Main functions in `phyr`.

```{r mainFunc, echo=FALSE}
read.csv("phyr_func.csv", check.names = FALSE) %>% 
  knitr::kable(caption = "(ref:maunFuncCaption)", booktab = T) %>%
  kableExtra::kable_styling(bootstrap_options = c("striped", "scale_down", "hover"),
                latex_options = c("striped")) %>% 
  kableExtra::column_spec(2, width = "25%")
```

## Phylogenetic diversity

The set of functions to calculate phylogenetic alpha (`psv`, `pse`, `psr`, `psc`, and `psd`) and beta (`pcd`) diversity was imported from the R package `picante` [@kembel2010picante]. Their theoretic bases were provided by @helmus2007phylogenetic (for alpha diversity) and @ives2010phylogenetic (for pairwise beta diversity). We improved the speed of these functions by rewriting key parts of the codes with c++. We added one argument `prune.tree` to the set of phylogenetic alpha diversity functions to allow users to decide whether to prune the phylogeny before converting it into a variance-covariance matrix; its default value is `FALSE`, which means that the phylogeny will first been converted into a variance-covariance matrix; the matrix was then subsetted to the keep only the species interested. These two methods of generating the variance-covariance matrix may have different results in some situations. We set the default to `FALSE` because this may give a more accurate matrix.

## Species' characteristics 

Two functions (`cor_phylo` and `binaryPGLMM`) were included in this group. Both of them were included in the R package `ape` [@ape2018] orginally.



The function `cor_phylo` computes Pearson correlation coefficients for multiple continuous
traits that may have phylogenetic signal, allowing users to also specify measurement
error.
The underlying methods were originally developed by @zheng2009new.
We improved speed by writing many of the internal functions in c++,
made the input format more flexible,
fixed a mistake that meant measurement error was not included, and
added two new features: parametric bootstrapping and the ability to use optimizers
from the `nlopt` library [@johnson2014nlopt; @powell2009bobyqa; @nelder1965simplex; @rowan1990functional].



`binaryPGLMM`: only 1 value per species, right?

## Community assembly

The original code for `communityPGLMM` were imported from the R package `pez` [@pearse2015pez]. Its theorectical background was presented in @ives2011generalized. We made several important updates here. First, function `pez::communityPGLMM` requires user-prepared random terms while `phyr::communityPGLMM` makes this step much easier by adapting formula syntax for mixed models provided by the R package `lme4` [@bates2015lme4]. To specify a random term with design matrix derived from a phylogenetic variance-covariance matrix, we can append two underscores (`__`) to the group variable. For example, `(1 | sp__)` will create *two* random terms: one with and one without (i.e. identity matrix) phylogenetic design matrix. To test whether closely related species are more or less likely to co-occur in the same site, we can use `(sp__@site)` along with the argument `repulsion = TRUE` (overdispersion) or `repulsion = FALSE` (underdispersion; default). Second, we extended `communityPGLMM` to work with Binomial and Poisson distributed data while `pez::communityPGLMM` only allows Binary and Gaussian data. Third, we provided both Maximum likelihood and Bayesian approaches to fit PGLMMs. Users can choose the approach via `bayes = TRUE` or `bayes = FALSE` (default). The Bayesian PGLMMs were fitted with integrated nested Laplace approximations (INLA) via the R package `r-inla` [@rue2009approximate]. Fourth, we improved the speed of `communityPGLMM` by rewriting key functions in c++.

The function `communityPGLMM` is modularized (prepare data, design matrix, optimization, etc.). (Too much details??)

The class of the model object returned is `communityPGLMM`, which has multiple methods (e.g., `print`, `summary`) associated with. Use `methods(class = 'communityPGLMM')` to see the full list. To visualize the design matrices' structures of random terms in the model object, we can use `communityPGLMM.plot.re()`. An example can be shown in Figure \@ref(fig:reStructure). It is also optional to simulate and plot data based on the design matrices with the argument `show.sim.image = TRUE`.

(ref:reStructureCaption) A figure to show the structures of design matrices of random terms in `communityPGLMM`.

```{r reStructure, fig.width=6, fig.height=6, fig.cap="(ref:reStructureCaption)"}
communityPGLMM.plot.re(x = pglmm_example, show.image = TRUE, show.sim.image = FALSE)
```

### Speed comparisons

A table to compare the speed of functions in `phyr` with their original versions.

# Example analysis

Simulation of data; then apply the main functions.

# Limitations

`communityPGLMM` requires columns `site` and `sp`.

# Conclusion

# Acknowledgements

# Authors' contributions

# Data Accessibility

# References
